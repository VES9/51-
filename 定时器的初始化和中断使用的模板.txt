/*
*   @Author:ZSX
*   @Date:
*   @Description:Configuration of timers and interrupt systems
*   @LastEditTime:
*   @LastEditors:ZSX
*   @Filepath:
*/


/**************************
定时器的配置：
1.  TMOD	的低4位为T0的控制字，TMOD 的高4位为T1的控制字
    TMOD的内部定义格式：	
		             高4位                                           低4位
		GATE 计数方式选择位（符号打不出来用汉字表示） M1 M0 | GATE 计数方式选择位 M1 M0
     默认0         默认0                                默认0     默认0                           

2.  M1 M0:工作方式位，其具体定义如下:

		M1    M0      工作方式          功能说明
		0     0          0          13位的定时器/计数器
    0     1          1          16位的定时器/计数器
		1     0          2          8位可重载的定时器/计数器
		1     1          3          3种定时器/计数器关系
		
3. @1  选定T0定时器 工作方式为0  延时1000us
       代码如下：
		 
				 void Timer0_init()
				{
						TMOD=0x00;             //TMOD= 0000 0000（选定T0定时器，高4位都为0，低4位为T0控制字，工作方式为0，故低4位为0000）
						TH0=(65536-1000)/256;  //延时1000us
						TL0=(65536-1000)%256;
						TR0=1;                 //打开定时器T0
				}
		
		     void ISR_init()
				{
					EA=1;                    //打开总中断
					ET0=1;                   //打开定时器/计数器0的溢出中断允许位
					EX0=0;                   //打开外部中断0中断允许位
					ET1=0;                   //打开定时器/计数器1的溢出中断允许位
					EX1=0;                   //打开外部中断1中断允许位
					ES=0;                    //打开串行通信中断允许位
				}
		
		@2  选定T0定时器 工作方式为0 延时1000us
		        TMOD=0x00; //0000 0000
						TR0=1;
						TH0=(65536-1000)/256;
						TL0=(65536-1000)%256;
				选定T0定时器 工作方式为1 延时5000us  
		        TMOD=0x01; //0000 0001
            TR0=1;
            TH0=(65536-5000)/256;
						TL0=(65536-5000)%256;						
		    选定T0定时器 工作方式为2 延时10000us
		        TMOD=0x02; //0000 0010
						TR0=1;
						TH0=(65536-10000)/256;
						TL0=(65536-10000)%256;
		    选定T0定时器 工作方式为3 延时xus(注：此处只是举例子xus，实际编程应该填上具体的数字，比如10000 2000等等)
		        TMOD=0x03; //0000 0011
						TR1=1;
						TH0=(65536-X)/256;
						TL0=(65536-X)%256;
												
	      选定T1定时器 工作方式为0
		        TMOD=0x00; //0000 0000
						TR1=1;
						TH1=(65536-X)/256;
						TL1=(65536-X)%256;
				选定T1定时器 工作方式为1
		        TMOD=0x10; //0001 0000
						TR1=1;
						TH1=(65536-X)/256;
						TL1=(65536-X)%256;
		     选定T1定时器 工作方式为2
		        TMOD=0x20; //0010 0000
						TR1=1;
						TH1=(65536-X)/256;
						TL1=(65536-X)%256;
					选定T1定时器 工作方式为3
		        TMOD=0x20; //0011 0000
						TR1=1;
						TH1=(65536-X)/256;
						TL1=(65536-X)%256;
						
***************************/



#include <REGX51.H>
/**************************
定时器0初始化
***************************/
void Timer0_init()
{
	TMOD=0x01;
	TH0=(65536-1000)/256;
	TL0=(65536-1000)%256;
	TR0=1;
}

/**************************
定时器1初始化
***************************/
//void Timer1_init()
//{
//	TMOD=0x10;
//	TH1=0;
//	TL1=0;
//	TR1=1;
//}

/**************************
中断初始化
***************************/
void ISR_init()
{
	EA=1;
	ET0=1;
	EX0=0;
	ET1=0;
	EX1=0;
	ES=0;
}

/**************************
定时器0溢出处理
***************************/

void OverFlow_Timer0()
{
	uchar p=0;
	if(TF0==1)
	{
		p++;
		TF0=0;
	}
	if(P=10)
	{
		//FUNCTION_0
		delay(2);
		p=0;
	}
}

/**************************
定时器1溢出处理
***************************/

void OverFlow_Timer1()
{
	uchar q=0;
	if(TF1==1)
	{
		q++;
		TF1=0;
	}
	if(q=10)
	{
		//FUNCTION_1
		delay(2);
		q=0;
	}
}

/**************************
外部中断0中断服务
***************************/
void Service_IE0() interrupt 0
{
 
}

/**************************
定时器0中断服务
***************************/
void Service_Timer0() interrupt 1
{
//	uchar count=0;
//	TH0=valueh[count];
//	TL0=valueh[count];
//	count++;
	uchar count0=0;
	TH0=(65536-1000)/256;
	TL0=(65536-1000)%256;
	count0++;
	if(count0==20)
		count0=0;
	if(count0>=speedvalue)
	{
		EN1=1;
	}
	else
	{
		EN1=0;
	}
	
//	IN2=~IN2;
//	if(count==2)
//	{
//		IN2=~IN2;
//		count=0;
//	}
}

/**************************
外部中断1中断服务
***************************/
void Service_IE0() interrupt 2
{
 
}

/**************************
定时器1中断服务
***************************/
void Service_Timer1() interrupt 3
{
	uchar count1=0;
	TH1=0;
	TL1=0;
	if(count1==20)
	{
		count1=0;
    TR1=0;
		speed=TH0;	
	  speed=(speed<<8)|TL0;
    //	speed+=TL0;	 
	  speed=speed*2.49504;
		flag=~flag;
    TR1=1;
	}
}
/**************************
串行通信中断服务
***************************/
void Service_SCON() interrupt 4
{
	
}
	
	